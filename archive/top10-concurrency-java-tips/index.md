---
templateKey: blog-post
title: Перевод. Подборка практик Сoncurrency программирования
date: 2015-06-10T19:18:06.000Z
description: Перевод. Подборка практик Сoncurrency программирования
tags:
- Old posts
---

![Multithreading and Concurrency Best Practices in Java](/img/8032829f-3e30-457a-a654-eaebf668a432.jpg)Разработка Concurrent-кода сложная задача. Тестирование такого кода еще более сложная задача. Поэтому язык программирования Java предоставляет различные приемы для синхронизации и поддержки многопоточности как на уровне язык, так и на уровне API. Что в конечном итоге при правильном применении помогает разрабатывать эффективный и bug-free concurrency код. Здесь собраны Java concurrency и multithreading рекомендации. Некоторые из Вас могут быть знакомы с некоторыми из них, но иногда бывает, что они вылетают из головы с течением лет. Данные советы основаны на моем опыте программирования и книгах [Effective Java](http://www.amazon.com/dp/0321356683/?tag=javamysqlanta-20) and [Java Concurrency in Practice](http://www.amazon.com/dp/0321349601/?tag=javamysqlanta-20)[.](http://4.bp.blogspot.com/-IZ9m6cCyWYA/VWXWGkCA0yI/AAAAAAAACz0/GW4S9QFgq2s/s1600/Java%2BMulti-threading%2BBest%2BPractices.jpg) Я крайне рекомендую прочитать эти книги пару раз.[](http://4.bp.blogspot.com/-IZ9m6cCyWYA/VWXWGkCA0yI/AAAAAAAACz0/GW4S9QFgq2s/s1600/Java%2BMulti-threading%2BBest%2BPractices.jpg)Оригинал можно прочитать [тут](http://javarevisited.blogspot.ru/2015/05/top-10-java-multithreading-and.html). Единственная цель использования многопоточности \- это создание масштабируемых и высокопроизводительных приложений. Но необходимо всегда помнить, что корректность и правильность работы приложения важнее его скорости. При работе с несколькими потоками, ваше приложения должно воспроизводить те же результаты как, если бы оно работало последовательно.

### 1) Используй локальные переменные

Всегда пытайся использовать локальные переменные вместо создания классов или использования поля объекта. Иногда, для доступа к переменным разработчики используют поля объекта, полагая, что таким образом сохраняется память при повторном использовании поля, так как при создании локальных переменных каждый раз будет выделять память. **Рассмотрим следующую задачу**: Сообщения Т1 поступает следом за сообщением Т2 в метод обработчик. При вызове функции из разных поток, обработка сообщения Т2 может произойти раньше. И вызов метода **_temp.clear()_** может привезти к порче данных в списке.

public class ConcurrentTask{
    private static List temp = Collections.synchronizedList(new ArrayList());
 
    @Override
    public void execute(Message message){
        //I need a temporary ArrayList here, use local
        //List temp = new ArrayList();
     
        //add something from Message into List
        temp.add(message.getId());
        temp.add(message.getCode());
     
        //combine id and code store result back to message
        temp.clear(); // Let's resuse it
    }
}

**Решение :** 1) Добавить блок синхронизации. Включить в него все взаимодействия со списком **_temp_**. Тогда не один из потоков не сможет получить доступ к списку **_temp_**, пока один не закончит свое выполнение. Такой подход приведет к тому, что приложение будет работать как в одном потоке. Тем самым уменьшив произвотельность. 2) Использовать локальную переменную вместо глобальной. Да это приведет к выделению дополнительной памяти, но вам не придется задумываться о синхронизации. Сильно не песпокойтесь о выделенной памяти, сборщик мусора без проблем освободит память.

### 2) Используй неизменяемые(Immutable) классы

Другая широко известная практика \- использовать неизменяемые класса. Такие классы, как String, Integer, BigDecimal и другие классы обертки, очень сильно облегчают разработчику многопоточных программ задачу, так как ему не нужно песпокоится о состоянии такого объекта. После создания неизменяемого класса, его состояние невозможно изменить. Очень хороший пример класс String, любые действия над объектом String приводят к созданию новго объекта String.

### 3) Сокращай размер блока синхронизации

Код внутри блока синхронизации не будет исполняться параллельно. И если вы имеет 5% вашего кода внутри такого блока, тогда, согласно [закону Амдала](https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%BA%D0%BE%D0%BD_%D0%90%D0%BC%D0%B4%D0%B0%D0%BB%D0%B0), производительность вашего приложения не может быть улучшена больше чем в 20 раз. Главная причина в том, что 5% кода всегда исполняется последовательно. Совет заключается в том, чтобы блокировать только критические секции кода. Если код не нуждается в синхронизации, его необходимо исключить из критической секции. Один из лучших примеров выделения критической секции - это [double checked locking idiom](http://javarevisited.blogspot.sg/2014/05/double-checked-locking-on-singleton-in-java.html).

### 4) Используй пул потоков

Создание потока \- тяжелая операция. Если вы хотите, чтобы ваше Java приложение было масштабируемо, вам необходимо использовать пул потоков. Управление потоком требует написания boiler-plate кода, этот код будет смешан с бизнес логикой, что уменьшит его читаемость. Управление потоками - задача либо внутреннего Java фреймворка, либо любого другого фреймворка. В JDK есть встроенный [Executor](http://javarevisited.blogspot.sg/2013/07/how-to-create-thread-pools-in-java-executors-framework-example-tutorial.html) фреймворк, который обеспечивает управление потоками.

### 5) Пользуйся встроенными методами синхронизации

Начиная с версии 1.5 в Java добавлено множество классов для поддержки синхронизации, например, CycicBariier, CountDownLatch and Sempahore. Вам всегда следует взглянуть на возможности JDK, прежче чем использовать wait и notify. Например, реализовать шаблон Producer-Consumer намнго проще с помощью класса BlockingQueue. Оцените все позможности JDK, изучив пакет java.util.concurrent.

### 6) Пользуйся BlockingQueue

BlockingQueue один из лучших вариантов при реализации паттерна Producer-Consumer для много поточных приложений. Такая очередь способна облуживать несколько поставщиков и потребителей сообщений. Подробнее об этом классе можно прочитать по [ссылки](http://javarevisited.blogspot.sg/2012/02/producer-consumer-design-pattern-with.html).

### 7) Используй Concurrent коллекции

В моем посте о [Top 5 Concurrent Collections in Java](http://javarevisited.blogspot.sg/2013/02/concurrent-collections-from-jdk-56-java-example-tutorial.html) рассказывалось, что Concurrent коллекции более масштабируемы и производительны, чем их synchronized аналоги. Например, ConcurrentHashMap - одна из самых популярных коллекций, ее следует использовать если число потоков для чтения из Map намного больше числа потоков записи в него. Другое преимущество Concurrent коллекций - это использование в них нового механизма блокировок.

### 8) Пользуйся семафорами

При разработке надежных и стабильных систем вы должны ограничивать доступ к ресурсам таким, как базны данных, файловая система итд, иначе ваш код сможет создавать или использовать бесконечно число ресурсов, что замедлит всю систему. Семафор хороший выбор для установки предела на использования дорогих ресурсов, например, соединение к базе данных. Для того, чтобы построить надежную и стабильную систему, вы должны иметь границы на такие ресурсы, как базы данных, файловой системы и т.д., розетки в коем ситуации, ваш код создавать или использовать бесконечное количество ресурсов. Семафор хороший выбор, чтобы иметь предел на дорогой ресурс, как соединения с базой данных, кстати, что оставить вашего бассейна Connection. Семафор очень полезно создание границ и блокировки нить, если ресурс не доступен. Вы можете следить за этот учебник, чтобы узнать, как использовать семафор использование в Java. Семафор поможет для создания ограничений и блокировки потока, если ресурс недоступен. Вы можете изучить [мою статью](http://javarevisited.blogspot.sg/2012/05/counting-semaphore-example-in-java-5.html) о семафорах для лучшего их понимания.

### 9) Используй synchronized блок

Использование блока synchronized сокращает размер критической области и позволяет блокировать любой объект.

### 10) Используй семество классов Lock

Lock интерфейс имеет мощный функционал. Различные Lock'и для операций чтения и записи позволяют создавать масштабируемые структуры данных, например, ConcurrentHashMap. Lock работает немного иначе, чем блок synchronized. Вы должны вызывать метод unlock() для разблокировки и лучше это делать в блоке finally:

lock.lock();
try {
    //do something ...
} finally {
  lock.unlock();
}

