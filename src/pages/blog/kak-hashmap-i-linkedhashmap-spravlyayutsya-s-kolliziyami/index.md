---
templateKey: blog-post
title: Как HashMap и LinkedHashMap справляются с коллизиями.
date: 2016-02-01T11:02:35.000Z
description: Как HashMap и LinkedHashMap справляются с коллизиями.
tags:
- Old posts
---

До Java 8 **HashMap** и другие хэш-таблицы, имплементирующие интерфейс **Map**, использовали **LinkedList** для хранения элементов в bucket'е при возникновении коллизии. Если ключ попал в bucket, в котором уже была запись с таким ключем, то запись просто добавляется в начало списка. В худшем случае данный подход ухудшал производительность метода get(/img/) с O(1) до O(n). Чтобы решить данную проблему в Java 8 вместо **LinkedList** используется сбалансированное дерево. А это означает, что в худшем случае вы получите прибавку в производительности до O(log(n)). ![ITCuties-HashMap-HashTable-linear-probing-and-separate-chaining](eaee5d9a-d9f5-4ac2-853c-b1b2e2a45f19.png) Переключение на использование дерева срабатывает при достижение порога **TREEIFY_THRESHOLD**, заданного в классе **java.util.HashMap**. Сейчас константа **TREEIFY_THRESHOLD** равна 8. Т.е. при хранении больше 8 элементов в одном bucket **HashMap** переключается на использование дерева. Данное изменение дополняет список улучшений в Java коллекциях. В JDK 7 было включено изменение, которое уменьшало объем использованной памяти для пустых **ArrayList** и **HashMap**. Это достигалось lazy-инициализацией массивов. Режим переключения на дерево не включен в классы **Hashtable**,** IdentityHashMap** и **WeakHashMap**. Поэтому данный режим поддерживается только в следующих классах:

*   **ConcurrentHashMap**
*   **LinkedHashMap**
*   **HashMap**